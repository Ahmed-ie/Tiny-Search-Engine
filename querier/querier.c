/**
 * Ahmed's querier
 * Author: Ahmed
 * File: querier.c
 *
 * This file implements the core functionality of the querier component of a tiny search engine.
 * It reads the index generated by the indexer and interacts with the user to accept queries.
 * It processes these queries against the indexed data to find and return the most relevant documents.
 * The querier supports complex queries with logical 'and' and 'or' operations and provides a ranking of results.
 */

#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "hashtable.h"
#include "counters.h"
#include "file.h"
#include "webpage.h"
#include "index.h"

// Document structure to hold the document ID and score.
typedef struct {
    int docID;
    int score;
} doc_t;

// Dynamic array to hold documents found after query processing.
typedef struct {
    doc_t *array;
    int index;
    int size;
} doc_array_t;

// Helper structure for passing two sets of counters to iterators.
typedef struct two_sets {
    counters_t *ctr1; // Existing results
    counters_t *ctr2; // New word counters
} two_sets_t;

// Forward declarations
bool parse_query(const char* input, char** words);
void process_queries(index_t* index, char* pageDirectory);
char** tokenize_query(char* query, int* numTokens);
bool validate_query(char** tokens, int numTokens);
counters_t* score_query(char** words, int numWords, index_t* index);
void print_results(counters_t* results, char* pageDirectory);
int compare_score(const void* a, const void* b);
void free_tokens(char** tokens, int numTokens);
void count_size(void* arg, const int key, const int count);
void sort_helper(void* arg, const int key, int count);
doc_t* sort_results(counters_t* results, int numResults);
char* getURL(int docID, const char* pageDirectory);
index_t* index_load(FILE* fp, int num_slots);
void counter_set_wrapper(void *arg, const int key, const int count);
void intersection_helper(void *arg, const int key, const int count);
counters_t* intersect_counters(counters_t *result, counters_t *temp);
counters_t* union_counters(counters_t *result, counters_t *temp);
void union_helper(void *arg, const int key, const int count);

/**
 * The main entry point for the querier program, which handles command line arguments and initiates the query processing loop.
 * 
 * @param argc The number of command line arguments.
 * @param argv The command line arguments, expected to include the directory of the page and the index filename.
 * @return Returns 0 on successful execution, and a non-zero value on errors such as incorrect arguments or file access issues.
 */

int main(int argc, char* argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s pageDirectory indexFilename\n", argv[0]);
        return 1;
    }

    char* pageDirectory = argv[1];
    char* indexFilename = argv[2];

    FILE* fp = fopen(indexFilename, "r");
    if (!fp) {
        fprintf(stderr, "Could not open index file %s for reading.\n", indexFilename);
        return 3;
    }

    index_t* index = index_load(fp, 500);
    fclose(fp);
    if (!index) {
        fprintf(stderr, "Failed to load index from %s\n", indexFilename);
        return 4;
    }

    process_queries(index, pageDirectory);
    index_delete(index);
    return 0;
}

/**
 * Handles the continuous query processing, prompting the user for input, and displaying the search results.
 * 
 * @param index The index structure containing the mappings of words to document IDs and their associated scores.
 * @param pageDirectory The directory containing the indexed pages.
 */

void process_queries(index_t* index, char* pageDirectory) {
    char* query;
    printf("Query? ");
    while ((query = file_readLine(stdin)) != NULL) {
        char* original_query = query;  // Save the original pointer to free memory later

        // Trim leading spaces by advancing the pointer
        while (isspace((unsigned char)*query)) query++;

        // Trim trailing spaces
        char* end = query + strlen(query) - 1;
        while (end > query && isspace((unsigned char)*end)) end--;
        *(end + 1) = '\0';

        // Convert query to lowercase.
        for (char* p = query; *p; p++) {
            *p = tolower((unsigned char)*p);
        }

        // Tokenize and process the query if valid.
        char** words;
        int numWords = 0;
        words = tokenize_query(query, &numWords);
        if (numWords > 0 && validate_query(words, numWords)) {
            counters_t* results = score_query(words, numWords, index);
            if (results) {
                print_results(results, pageDirectory);
                counters_delete(results);
            } else {
                printf("No documents match.\n");
            }
        }
        free_tokens(words, numWords);
        free(original_query);  // Free the original allocated memory
        printf("Query? ");
    }
}

/**
 * Tokenizes the user input query into individual words.
 * 
 * @param query The user input string.
 * @param numTokens Pointer to store the number of tokens.
 * @return Array of tokenized words.
 */

char** tokenize_query(char* query, int* numTokens) {
    char** tokens = NULL;
    int capacity = 0, size = 0;
    char* token = strtok(query, " ");
    while (token) {
        if (size >= capacity) {
            capacity = capacity > 0 ? capacity * 2 : 4;
            tokens = realloc(tokens, capacity * sizeof(char*));
        }
        tokens[size++] = strdup(token);
        token = strtok(NULL, " ");
    }
    *numTokens = size;
    return tokens;
}

/**
 * Validates the tokenized query, ensuring proper usage of logical operators.
 * 
 * @param tokens Array of tokenized words.
 * @param numTokens Number of tokens.
 * @return True if the query is valid, false otherwise.
 */

bool validate_query(char** tokens, int numTokens) {
    if (numTokens == 0) {
        printf("Error: Empty query.\n");
        return false;
    }
    for (int i = 0; i < numTokens; i++) {
        // Check if the token is 'and' or 'or' which do not need character validation
        if (strcmp(tokens[i], "and") != 0 && strcmp(tokens[i], "or") != 0) {
            for (int j = 0; tokens[i][j]; j++) {
                if (!isalpha(tokens[i][j])) {
                    printf("Error: Query contains invalid characters.\n");
                    return false;
                }
            }
        }

        if ((strcmp(tokens[i], "and") == 0 || strcmp(tokens[i], "or") == 0) && (i == 0 || i == numTokens - 1)) {
            printf("Error: Query cannot start or end with operators 'and' or 'or'.\n");
            return false;
        }
        if (i > 0 && (strcmp(tokens[i], "and") == 0 || strcmp(tokens[i], "or") == 0) &&
            (strcmp(tokens[i - 1], "and") == 0 || strcmp(tokens[i - 1], "or") == 0)) {
            printf("Error: Query contains consecutive operators.\n");
            return false;
        }
    }
    return true;
}

/**
 * Handles setting the counters during the scoring phase.
 * 
 * @param arg Pointer to the counters structure.
 * @param key Document ID.
 * @param count Score to be set.
 */

void counter_set_wrapper(void *arg, const int key, const int count) {
    counters_t *ctrs = (counters_t *)arg;
    counters_set(ctrs, key, count);
}

/**
 * Scores the query by intersecting or unioning the result sets of individual query terms.
 * 
 * @param words Array of words from the query.
 * @param numWords Number of words.
 * @param index The index loaded with document data.
 * @return A counters structure with document scores.
 */

counters_t* score_query(char** words, int numWords, index_t* index) {
    counters_t* result = NULL;

    for (int i = 0; i < numWords; i++) {
        if (strcmp(words[i], "and") == 0 || strcmp(words[i], "or") == 0) {
            continue; // Skip operators in the initial loop.
        }

        counters_t* word_counters = index_get(index, words[i]);
        if (word_counters == NULL) continue;

        if (result == NULL) { // First valid word found.
            result = counters_new();
            counters_iterate(word_counters, result, counter_set_wrapper);
        } else if (i > 0 && strcmp(words[i-1], "and") == 0) {
            // Intersect current results with new word counters
            counters_t* intersection = intersect_counters(result, word_counters);
            counters_delete(result);  // Free the old result
            result = intersection;
        } else if (i > 0 && strcmp(words[i-1], "or") == 0) {
            // Union current results with new word counters
            counters_t* union_result = union_counters(result, word_counters);
            counters_delete(result);  // Free the old result
            result = union_result;
        }
    }

    return result;
}

/**
 * Intersects two counters sets, producing a new set with the minimum score for each document ID present in both sets.
 * 
 * @param ctr1 The first counters set.
 * @param ctr2 The second counters set.
 * @return A new counters set with intersected scores.
 */

counters_t* intersect_counters(counters_t *ctr1, counters_t *ctr2) {
    if (!ctr1 || !ctr2) return NULL;

    counters_t *result = counters_new();
    if (!result) return NULL;

    two_sets_t sets = {result, ctr2};
    counters_iterate(ctr1, &sets, intersection_helper);

    return result;
}

/**
 * Helper function for intersecting counters. It sets the score for each document ID in the result
 * to the minimum of the scores from two counters.
 * 
 * @param arg Pointer to the two_sets_t structure containing the result and the second counters set.
 * @param key The document ID.
 * @param count1 The score from the first counters set.
 */

void intersection_helper(void *arg, const int key, const int count1) {
    two_sets_t *sets = (two_sets_t *)arg;
    int count2 = counters_get(sets->ctr2, key);
    if (count1 > 0 && count2 > 0) {
        counters_set(sets->ctr1, key, (count1 < count2) ? count1 : count2);
    } else {
        counters_set(sets->ctr1, key, 0);
    }
}


/**
 * Unions two counters sets, modifying the first set to include the combined scores for each document ID.
 * 
 * @param ctr1 The counters set to modify.
 * @param ctr2 The counters set to merge with the first.
 * @return The modified first counters set.
 */

counters_t* union_counters(counters_t *ctr1, counters_t *ctr2) {
    if (!ctr1) return NULL;

    if (!ctr2) return ctr1; // If second counter is NULL, return first as is.

    counters_iterate(ctr2, ctr1, union_helper);
    return ctr1;
}

/**
 * Helper function for unioning counters. It increments the score for each document ID in the first counters set
 * by the score from the second counters set.
 * 
 * @param arg Pointer to the first counters set.
 * @param key The document ID.
 * @param count The score from the second counters set to add to the first.
 */

void union_helper(void *arg, const int key, const int count) {
    counters_t *ctr1 = (counters_t *)arg;
    int existing_count = counters_get(ctr1, key);
    counters_set(ctr1, key, existing_count + count);
}

/**
 * Prints the results of the query after sorting the documents by score in descending order.
 * 
 * @param results The counters set containing document scores.
 * @param pageDirectory The directory path where the documents are stored.
 */

void print_results(counters_t* results, char* pageDirectory) {
    int numResults = 0;
    counters_iterate(results, &numResults, count_size);

    if (numResults == 0) {
        printf("No matches found.\n");
        return;
    }

    doc_t* sortedResults = sort_results(results, numResults);
    printf("Found %d documents (sorted by relevance):\n", numResults);

    for (int i = 0; i < numResults; i++) {
        if (sortedResults[i].score > 0) {  // Ensure only positive scores are printed
            int docID = sortedResults[i].docID;
            int score = sortedResults[i].score;
            char* url = getURL(docID, pageDirectory);
            printf("Score: %d DocID: %d URL: %s\n", score, docID, url);
            free(url);
        }
    }
    free(sortedResults);
}

/**
 * Sorts the results by score in descending order and prepares them for display.
 * 
 * @param results The counters set containing document scores.
 * @param numResults The number of results to sort.
 * @return An array of doc_t containing the sorted document data.
 */

doc_t* sort_results(counters_t* results, int numResults) {
    doc_t* docs = malloc(numResults * sizeof(doc_t));
    doc_array_t data = {docs, 0, numResults};
    counters_iterate(results, &data, sort_helper);
    if (data.index > 0) {
        qsort(docs, data.index, sizeof(doc_t), compare_score); // Sort based on the actual number of results added to the array
    }

    return docs;
}

/**
 * Helper function for sorting documents by their scores.
 * 
 * @param arg Pointer to the doc_array_t structure to populate.
 * @param key The document ID.
 * @param count The score for the document.
 */

void sort_helper(void* arg, const int key, int count) {
    doc_array_t* data = arg;
    if (count > 0) {
        data->array[data->index].docID = key;
        data->array[data->index].score = count;
        data->index++;
    }
}

/**
 * Compares two documents based on their scores to determine their order in the sorted results.
 * 
 * @param a Pointer to the first doc_t to compare.
 * @param b Pointer to the second doc_t to compare.
 * @return Negative if a's score is higher, positive if b's score is higher, zero if they are equal.
 */

int compare_score(const void* a, const void* b) {
    const doc_t* docA = a;
    const doc_t* docB = b;
    return (docB->score - docA->score);
}

/**
 * Frees memory allocated for an array of tokens.
 * 
 * @param tokens An array of strings representing tokens.
 * @param numTokens The number of tokens in the array.
 */

void free_tokens(char** tokens, int numTokens) {
    for (int i = 0; i < numTokens; i++) {
        free(tokens[i]);
    }
    free(tokens);
}

/**
 * Retrieves the URL from a file corresponding to a document ID within a specified directory.
 * Each document file is expected to start with the URL as the first line.
 * 
 * @param docID The document ID corresponding to the file to be opened.
 * @param pageDirectory The directory path where the document files are stored.
 * @return A string containing the URL read from the file, or NULL if the file cannot be opened.
 */

char* getURL(int docID, const char* pageDirectory) {
    char path[256];
    snprintf(path, sizeof(path), "%s/%d", pageDirectory, docID);
    FILE* fp = fopen(path, "r");
    if (!fp) {
        fprintf(stderr, "Failed to open document file %s.\n", path);
        return NULL;
    }

    char* url = file_readLine(fp);
    fclose(fp);
    return url;
}

/**
 * A helper function used during the scoring process to count the number of results that have a score greater than zero.
 * This function is typically used with counters_iterate to determine the total number of results.
 * 
 * @param arg Pointer to an integer to increment for each result with a score greater than zero.
 * @param key The document ID, not used in this function.
 * @param count The score associated with the document ID.
 */

void count_size(void* arg, const int key, const int count) {
    //printf("Document ID: %d, Score: %d\n", key, count);
    if (count > 0) {
        int* numResults = arg;
        (*numResults)++;
    }
}
